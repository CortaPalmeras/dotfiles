# ~/.bashrc
# ---------
#  options
# ---------

# autocd: dirnames as cd commands.
# cdspell: spelling mistakes.
# histappend: append to the history file.
# checkwinsize: update the values of LINES and COLUMNS.
# globstar: ** matches files on subdirectories
shopt -s autocd histappend checkwinsize globstar

# -------------
#  Environment
# -------------

PATH="$HOME/.local/bin:$PATH"

export MANPATH="$HOME/.local/share/man:$MANPATH"

export VISUAL=vim
export EDITOR=vim
export SUDO_EDITOR=vim

export LESS='--ignore-case --incsearch --mouse --use-color'
export BAT_THEME='catppuccin-mocha'
export MANPAGER="sh -c 'col -bx | bat --style plain --language man'"

export VIRTUAL_ENV_DISABLE_PROMPT=1
export LIBVIRT_DEFAULT_URI='qemu:///system'

export NVM_DIR="$HOME/.nvm"

# -------------
#  Completions
# -------------

. /usr/share/bash-completion/bash_completion

for COMPLETION in "$HOME/.local/share/bash-completion/completions/"*; do
    [[ -r "$COMPLETION" ]] && source "$COMPLETION"
done


# ---------
#  Aliases
# ---------

alias l='ls'
alias sl='ls'
alias atp='apt'
alias nivm='nvim'
alias ncim='nvim'
alias suod='sudo'

alias ls='ls --color=auto --hyperlink=auto --classify=auto'
alias ll='ls -l --human-readable'
alias la='ls --almost-all'
alias lal='ll --almost-all'
alias lla='lal'

alias cd..='cd ..'
alias virsh='virsh -c qemu:///system'

just () {
    $@ &>/dev/null &
    disown '%$@';
}

back-search() {
    local current_dir="$PWD"

    while [[ -n "$current_dir" ]]; do
        local found_path="$current_dir/$2" 

        if test $1 "$found_path"; then
            echo $found_path
            return 0
        fi

        current_dir=${current_dir%/*}
    done

    return 1
}

envexport() {
    local env_path="$(back-search -f '.env')"

    if [[ $? == 0 ]]; then
        while read -r line; do
            export $line
            echo "export $line"
        done < $env_path

        return 0
    fi

    echo "Env file not found"
    return 1
}

pretty_path() {
    local res=${1#$PWD}
    if [[ $res != $1 ]]; then
        echo ".$res"
        return
    fi

    local prev_dir=${PWD%/*}
    res=${1#$prev_dir}
    if [[ $res != $1 ]]; then
        echo "..$res"
        return
    fi

    res=${1#$HOME}
    if [[ $res != $1 ]]; then
        echo "~$res"
        return
    fi
}

pyactivate() {
    if [[ -v VIRTUAL_ENV ]]; then
        echo "Enviroment variable VIRTUAL_ENV is set, deactivate the current virtual environment."
        return 1
    fi

    local venv_dir="$1"
    if [[ -z $1 ]]; then
        venv_dir="venv"
    fi

    local script_path
    script_path="$(back-search -f "$venv_dir/bin/activate")"

    if [[ $? == 0 ]]; then
        source $script_path
        echo "VIRTUAL_ENV=$(pretty_path $VIRTUAL_ENV)"
        return 0
    fi

    echo "Virtual environment not found."
    return 1
}

nvm-export() {
    source "$NVM_DIR/nvm.sh"
    source "$NVM_DIR/bash_completion"
    unset nvm-export
}

idf-export() {
    source $HOME/Repos/esp-idf/export.sh
    unset idf-export
}

# --------
#  Prompt
# --------

logo_col='\[\e[91m\]'
host_col='\[\e[94m\]'
dir_col='\[\e[95m\]'
git_col='\[\e[96m\]'
exit_col='\[\e[91m\]'
prompt_col='\[\e[37m\]'
no_col='\[\e[0m\]'

prompt_icon='$'
dir_sep='...'

git_branch='(b:'
git_tag='(t:'
git_commit='(c:'
git_end=')'

exit_icon='(e:'
exit_end=')'

if [[ "$TERM" == "xterm-kitty" ]]; then
    logo_icon=' '
    prompt_icon=''
    dir_sep='....'

    git_branch=''
    git_tag=''
    git_commit=''
    git_end=''

    exit_icon=''
    exit_end=''

    ps1_start='\[\e]133;A\a\]'
    ps1_end='\[\e]133;B\a\]'

    ps2_start='\[\e]133;A;k=s\a\]'
    ps2_end='\[\e]133;B;k=s\a\]'

    cmd_start='\[\e]133;C\a\]'
    cmd_end='\[\e]133;D;$?\a\]'
fi

exit_status=''
short_dir=''
git_status=''
git_status_update_pending=1; 

alias cd='git_status_update_pending=1; builtin cd'
alias git='git_status_update_pending=1; git'
alias lazygit='git_status_update_pending=1; lazygit'

update_git_status() {
    # if on a branch
    git_status=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [[ -n $git_status ]]; then
        git_status="$git_branch $git_status$git_end "
        return
    fi

    # if on a tag
    git_status=$(git describe --tags --exact-match 2>/dev/null)
    if [[ -n $git_status ]]; then
        git_status="$git_tag $git_status$git_end "
        return
    fi

    # else use commit hash
    git_status="$git_commit $(git rev-parse --short HEAD 2>/dev/null)$git_end "
}

update_prompt() {
    # update exit status
    exit_status=$?
    if [[ $exit_status == 0 ]]; then
        exit_status=''
    else
        exit_status="$exit_icon $exit_status$exit_end "
    fi

    # update formatted dir
    short_dir="$PWD"
    if [[ $short_dir == '/' ]]; then
        short_dir='/'
    else
        short_dir=${short_dir/#$HOME/'~'}
        short_dir=${short_dir#/}
        short_dir=${short_dir/\/*\//\/$dir_sep\/}
    fi

    if [[ -n "$git_status_update_pending" ]]; then
        git_status_update_pending=''
        git_status=''
        git_dir=$(back-search -d .git)
        [[ $? == 0 ]] && update_git_status
    fi
}

PROMPT_COMMAND=update_prompt
PS0="$cmd_start"

PS1="$cmd_end$ps1_start$no_col\
$logo_col$logo_icon\
$host_col\u@\H \
$dir_col\$short_dir \
$git_col\$git_status\
$exit_col\$exit_status\
$prompt_col$prompt_icon\
$no_col "

PS2="$ps2_start$prompt_col$prompt_icon$no_col $ps2_end"

